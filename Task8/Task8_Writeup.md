
# **Task 8 - Raiding the Vault**

## <ins>Topics:</ins>

Reverse Engineering, [redacted]

## <ins>Task Description<ins>

You're an administrator! Congratulations!

It still doesn't look like we're able to find the key to recover the victim's files, though. Time to look at how the site stores the keys used to encrypt victim's files. You'll find that their database uses a "key-encrypting-key" to protect the keys that encrypt the victim files. Investigate the site and recover the key-encrypting key.

## <ins>Provided Files<ins>

None

## <ins>Solution<ins>

### **1) Gathering information with admin access**

Now that we have access to the Admin panel, we start looking to see what new information we can access. Of note is a `Key Generation Log` box with a button `Retrieve List` that downloads a file `keygeneration.log`, which holds some data about ransoms. This log file is also referenced in the source code in `server.py` in the `lock` function. The full path for this file is shown to be `/opt/ransommethis/log/keygeneration.log`. Interestingly, the Developer tools Network tab shows this request is using query parameters in a GET request through the URL https://padytccfzhyzlaza.ransommethis.net/nukoscislzmqpewx/fetchlog?log=keygeneration.log to download the log. Since we have control of the query, we can try and download other files by altering the path.

Looking at other files referenced in the source code, we see `/opt/keyMaster/keyMaster`, `/opt/ransommethis/db/victims.db`, and `/opt/ransommethis/db/user.db` are some other files present. Looking at the `fetchlog` function in `server.py`, the request always has `/opt/ransommethis/log/` prepended, so we need to use relative paths. This means the remaining files can be downloaded by setting `log` to `../../keyMaster/keyMaster`, `../db/victims.db`, and `../db/user.db` in the URL above.

Looking through the source code for the site again, we see that `user.db` contains user information for users on the ransomware website, `victims.db` contains information on ransoms owed by victims, and `keyMaster` is an executable that is used generating and retrieving encryption keys and crediting attackers. This executable is of particular interest in finding the "key-encrypting-key" so we look further.

### **2) Reverse engineering keyMaster**

Running `file keyMaster` reveals that this is a golang binary. Loading the binary into Ghidra and analyzing it leads to an analysis that leaves a lot to be desired. After doing some research we can see that the way go binaries handle strings and function naming is quite differet from C/C++. Luckily, there are [scripts](https://github.com/getCUJO/ThreatIntel/tree/master/Scripts/Ghidra) available for use with Ghidra that can improve the analysis. Loading these scripts into Ghidra and running them improves things significantly.

Starting at `main.main`, we start looking at the various ways `keyMaster` can be invoked. The main methods are `unlock`, `lock `, and `credit`, of which `lock` is most interesting since it involves generating an encryption key, and likely the "key-encrypting-key" will be seen in action here. When `lock` mode is used, the function `main.DchO32CDDK` is called which uses `github.com/google/uuid.NewUUID` to generate a UUID. After this the function `main.mtHO6enMvyA` is called which generates an 32 byte AES key with `main.p4hsJ3KeOvw` by using `golang.org/x/crypto/pbkdf2.Key`, and finally uses this key and 16 random bytes as an IV to AES-256-CBC encrypt the UUID. Next, `main.XL95gzwGuD8` is called which opens a file called `keyMaster.db` and writes the encrypted key with IV and ransom information to the database. Finally, the plaintext UUID is printed to the console in a JSON string. Using the same technique as above, this file can be downloaded using the `fetchlog` endpoint with `log` set to `../../keyMaster/keyMaster.db`.

### **3) Extracting the key-encrypting-key**

There is probably a way to statically analyze the binary and calculate what the key generated by `main.p4hsJ3KeOvw` is, but a quicker method would be to use `gdb` for dynamic analysis. In Ghidra we can see that the next instruction address after the call to `main.p4hsJ3KeOvw` is at `0x5b87d5`. So we can set a breakpoint here and view the value returned in RAX to find the key we want.

Looking at `keyMaster.db` using a SQLite browser we see that the only hacker in the `hackers` table is `RoastedJudo` and they have no remaining credits. Editing the database we can give them 999 credits for use while we dynamically run `keyMaster`. Then, running `gdb --args keyMaster lock 0 1 RoastedJudo` we can start a `gdb` session and enter `b *0x5b87d5` to break right after `main.p4hsJ3KeOvw`. Then, we can use `r` to run and use `x/32bx $rax` to view the key in memory, which shows the key in hex as `da26e167d7417dfeedac8f54744e48fb8d4a604992a93ed865c32c5e03e56789`. Using CyberChef we can convert this to base64 using `From Hex` and `To Base64` to get our answer:

2ibhZ9dBff7trI9UdE5I+41KYEmSqT7YZcMsXgPlZ4k=